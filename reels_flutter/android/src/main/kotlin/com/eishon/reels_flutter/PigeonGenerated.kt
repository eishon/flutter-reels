// Autogenerated from Pigeon (v22.7.4), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")

package com.eishon.reels_flutter

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.EventChannel
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMethodCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  return if (exception is FlutterError) {
    listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

private fun createConnectionError(channelName: String): FlutterError {
  return FlutterError("channel-error",  "Unable to establish connection on channel: '$channelName'.", "")}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

/**
 * Configuration for the Reels SDK
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ReelsConfig (
  val autoPlay: Boolean,
  val showControls: Boolean,
  val loopVideos: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ReelsConfig {
      val autoPlay = pigeonVar_list[0] as Boolean
      val showControls = pigeonVar_list[1] as Boolean
      val loopVideos = pigeonVar_list[2] as Boolean
      return ReelsConfig(autoPlay, showControls, loopVideos)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      autoPlay,
      showControls,
      loopVideos,
    )
  }
}

/**
 * Data model for a video in the reels
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class VideoData (
  val id: String,
  val url: String,
  val thumbnailUrl: String? = null,
  val title: String? = null,
  val description: String? = null,
  val authorName: String? = null,
  val authorAvatarUrl: String? = null,
  val likeCount: Long? = null,
  val commentCount: Long? = null,
  val shareCount: Long? = null,
  val isLiked: Boolean? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): VideoData {
      val id = pigeonVar_list[0] as String
      val url = pigeonVar_list[1] as String
      val thumbnailUrl = pigeonVar_list[2] as String?
      val title = pigeonVar_list[3] as String?
      val description = pigeonVar_list[4] as String?
      val authorName = pigeonVar_list[5] as String?
      val authorAvatarUrl = pigeonVar_list[6] as String?
      val likeCount = pigeonVar_list[7] as Long?
      val commentCount = pigeonVar_list[8] as Long?
      val shareCount = pigeonVar_list[9] as Long?
      val isLiked = pigeonVar_list[10] as Boolean?
      return VideoData(id, url, thumbnailUrl, title, description, authorName, authorAvatarUrl, likeCount, commentCount, shareCount, isLiked)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      url,
      thumbnailUrl,
      title,
      description,
      authorName,
      authorAvatarUrl,
      likeCount,
      commentCount,
      shareCount,
      isLiked,
    )
  }
}

/**
 * Product information for tagging in reels
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ProductData (
  val id: String,
  val name: String,
  val imageUrl: String? = null,
  val price: Double? = null,
  val currency: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ProductData {
      val id = pigeonVar_list[0] as String
      val name = pigeonVar_list[1] as String
      val imageUrl = pigeonVar_list[2] as String?
      val price = pigeonVar_list[3] as Double?
      val currency = pigeonVar_list[4] as String?
      return ProductData(id, name, imageUrl, price, currency)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      name,
      imageUrl,
      price,
      currency,
    )
  }
}
private open class PigeonGeneratedPigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ReelsConfig.fromList(it)
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          VideoData.fromList(it)
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ProductData.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is ReelsConfig -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      is VideoData -> {
        stream.write(130)
        writeValue(stream, value.toList())
      }
      is ProductData -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/**
 * API called by native platform to communicate with Flutter
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface ReelsFlutterApi {
  /** Initialize the Reels SDK with configuration */
  fun initialize(config: ReelsConfig)
  /** Show reels with the provided video data */
  fun showReels(videos: List<VideoData>)
  /** Update a specific video's data (e.g., after a like/share) */
  fun updateVideo(video: VideoData)
  /** Close the reels view */
  fun closeReels()
  /** Update the configuration */
  fun updateConfig(config: ReelsConfig)

  companion object {
    /** The codec used by ReelsFlutterApi. */
    val codec: MessageCodec<Any?> by lazy {
      PigeonGeneratedPigeonCodec()
    }
    /** Sets up an instance of `ReelsFlutterApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: ReelsFlutterApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.reels_flutter.ReelsFlutterApi.initialize$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val configArg = args[0] as ReelsConfig
            val wrapped: List<Any?> = try {
              api.initialize(configArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.reels_flutter.ReelsFlutterApi.showReels$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val videosArg = args[0] as List<VideoData>
            val wrapped: List<Any?> = try {
              api.showReels(videosArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.reels_flutter.ReelsFlutterApi.updateVideo$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val videoArg = args[0] as VideoData
            val wrapped: List<Any?> = try {
              api.updateVideo(videoArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.reels_flutter.ReelsFlutterApi.closeReels$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.closeReels()
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.reels_flutter.ReelsFlutterApi.updateConfig$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val configArg = args[0] as ReelsConfig
            val wrapped: List<Any?> = try {
              api.updateConfig(configArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * API called by Flutter to communicate with native platform
 *
 * Generated class from Pigeon that represents Flutter messages that can be called from Kotlin.
 */
class ReelsNativeApi(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by ReelsNativeApi. */
    val codec: MessageCodec<Any?> by lazy {
      PigeonGeneratedPigeonCodec()
    }
  }
  /** Called when a reel is viewed (displayed for significant time) */
  fun onReelViewed(videoIdArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.reels_flutter.ReelsNativeApi.onReelViewed$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(videoIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /** Called when user likes/unlikes a video */
  fun onReelLiked(videoIdArg: String, isLikedArg: Boolean, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.reels_flutter.ReelsNativeApi.onReelLiked$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(videoIdArg, isLikedArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /** Called when user shares a video */
  fun onReelShared(videoIdArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.reels_flutter.ReelsNativeApi.onReelShared$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(videoIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /** Called when user comments on a video */
  fun onReelCommented(videoIdArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.reels_flutter.ReelsNativeApi.onReelCommented$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(videoIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /** Called when a product in the reel is clicked */
  fun onProductClicked(productIdArg: String, videoIdArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.reels_flutter.ReelsNativeApi.onProductClicked$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(productIdArg, videoIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /** Called when reels view is closed */
  fun onReelsClosed(callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.reels_flutter.ReelsNativeApi.onReelsClosed$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /** Called when an error occurs */
  fun onError(errorMessageArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.reels_flutter.ReelsNativeApi.onError$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(errorMessageArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /** Request access token for authenticated API calls */
  fun getAccessToken(callback: (Result<String?>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.reels_flutter.ReelsNativeApi.getAccessToken$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(null) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          val output = it[0] as String?
          callback(Result.success(output))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
}
